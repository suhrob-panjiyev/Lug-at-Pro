import streamlit as st
import random
import json
import csv
from pathlib import Path
import requests

APP_TITLE = "Mini Lug'at Test (CSV + Suggestions)"
BASE_CSV = Path("5000_lugat_en_uz.csv")
USER_DATA_FILE = Path("user_words.json")

# NEW: stats storage
STATS_FILE = Path("stats.json")

QUESTIONS_PER_TEST = 10

# ---------------------------
# Normalizers
# ---------------------------
def norm_en(s: str) -> str:
    return " ".join(s.strip().lower().split())

def norm_uz(s: str) -> str:
    return " ".join(s.strip().lower().split())

# ---------------------------
# CSV loader (BOM fixed)
# ---------------------------
def _clean_header(h: str) -> str:
    return str(h).replace("\ufeff", "").strip().lower()

def detect_columns(fieldnames):
    if not fieldnames:
        return None, None
    cleaned = [_clean_header(f) for f in fieldnames]

    en_candidates = ["en", "english", "word", "eng"]
    uz_candidates = ["uz", "uzbek", "translation", "meaning", "tr", "uzb"]

    en_col = None
    uz_col = None

    for c in en_candidates:
        if c in cleaned:
            en_col = fieldnames[cleaned.index(c)]
            break
    for c in uz_candidates:
        if c in cleaned:
            uz_col = fieldnames[cleaned.index(c)]
            break

    return en_col, uz_col

@st.cache_data(show_spinner=False)
def load_base_csv(path_str: str):
    path = Path(path_str)
    data = {}
    meta = {"ok": False, "rows": 0, "en_col": None, "uz_col": None, "error": None}

    if not path.exists():
        meta["error"] = f"CSV topilmadi: {path.resolve()}"
        return data, meta

    try:
        with path.open("r", encoding="utf-8-sig", newline="") as f:
            reader = csv.DictReader(f)
            en_col, uz_col = detect_columns(reader.fieldnames)

            meta["en_col"] = en_col
            meta["uz_col"] = uz_col

            if not en_col or not uz_col:
                meta["error"] = f"Ustun topilmadi. Fieldnames: {reader.fieldnames}"
                return data, meta

            for row in reader:
                meta["rows"] += 1
                en = (row.get(en_col) or "").strip()
                uz = (row.get(uz_col) or "").strip()
                if not en or not uz:
                    continue
                k = norm_en(en)
                data.setdefault(k, {"en": en, "uz_list": []})
                if all(norm_uz(uz) != norm_uz(x) for x in data[k]["uz_list"]):
                    data[k]["uz_list"].append(uz)

        meta["ok"] = True
        return data, meta

    except Exception as e:
        meta["error"] = str(e)
        return data, meta

# ---------------------------
# User words
# ---------------------------
def load_user_words():
    if not USER_DATA_FILE.exists():
        return {}
    try:
        raw = json.loads(USER_DATA_FILE.read_text(encoding="utf-8"))
        if not isinstance(raw, list):
            return {}
        data = {}
        for item in raw:
            if not isinstance(item, dict):
                continue
            en = str(item.get("en", "")).strip()
            uz_list = item.get("uz_list") or []
            uz_list = [str(x).strip() for x in uz_list if str(x).strip()]
            if not en or not uz_list:
                continue
            data[norm_en(en)] = {"en": en, "uz_list": uz_list}
        return data
    except Exception:
        return {}

def save_user_words(user_map: dict):
    arr = [{"en": v["en"], "uz_list": v["uz_list"]} for v in user_map.values()]
    USER_DATA_FILE.write_text(json.dumps(arr, ensure_ascii=False, indent=2), encoding="utf-8")

@st.cache_data(show_spinner=False)
def english_list_from_map(map_: dict):
    return sorted({v["en"] for v in map_.values()}, key=lambda x: x.lower())

def suggestions(query: str, english_list: list[str], limit=12):
    q = norm_en(query)
    if not q:
        return []
    starts = [w for w in english_list if w.lower().startswith(q)]
    if len(starts) >= limit:
        return starts[:limit]
    contains = [w for w in english_list if q in w.lower() and w not in starts]
    return (starts + contains)[:limit]

# ---------------------------
# Translation fallback
# ---------------------------
@st.cache_data(show_spinner=False)
def translate_mymemory(en_text: str):
    en_text = en_text.strip()
    if not en_text:
        return []
    url = "https://api.mymemory.translated.net/get"
    params = {"q": en_text, "langpair": "en|uz"}
    r = requests.get(url, params=params, timeout=12)
    r.raise_for_status()
    data = r.json()

    candidates = []
    main = (data.get("responseData") or {}).get("translatedText", "")
    if main:
        candidates.append(main)
    for m in (data.get("matches") or []):
        t = (m.get("translation") or "").strip()
        if t:
            candidates.append(t)

    cleaned, seen = [], set()
    for c in candidates:
        c2 = " ".join(c.strip().split())
        key = c2.lower()
        if c2 and key not in seen:
            seen.add(key)
            cleaned.append(c2)
    return cleaned[:10]

# ---------------------------
# Stats persistence (NEW)
# ---------------------------
def load_stats():
    """
    Structure:
    {
      "manual": {"attempts": 0, "total_q": 0, "correct_q": 0},
      "csv": {
         "tests": {
            "1": {"attempts": 1, "total_q": 10, "correct_q": 8},
            "2": {...}
         }
      }
    }
    """
    if not STATS_FILE.exists():
        return {"manual": {"attempts": 0, "total_q": 0, "correct_q": 0}, "csv": {"tests": {}}}
    try:
        obj = json.loads(STATS_FILE.read_text(encoding="utf-8"))
        if not isinstance(obj, dict):
            raise ValueError("bad stats")
        obj.setdefault("manual", {"attempts": 0, "total_q": 0, "correct_q": 0})
        obj.setdefault("csv", {"tests": {}})
        obj["csv"].setdefault("tests", {})
        return obj
    except Exception:
        return {"manual": {"attempts": 0, "total_q": 0, "correct_q": 0}, "csv": {"tests": {}}}

def save_stats(stats_obj: dict):
    STATS_FILE.write_text(json.dumps(stats_obj, ensure_ascii=False, indent=2), encoding="utf-8")

def record_manual_result(stats_obj: dict, correct: int, total: int):
    stats_obj["manual"]["attempts"] = int(stats_obj["manual"].get("attempts", 0)) + 1
    stats_obj["manual"]["total_q"] = int(stats_obj["manual"].get("total_q", 0)) + total
    stats_obj["manual"]["correct_q"] = int(stats_obj["manual"].get("correct_q", 0)) + correct

def record_csv_result(stats_obj: dict, test_id: int, correct: int, total: int):
    t = stats_obj["csv"]["tests"].get(str(test_id), {"attempts": 0, "total_q": 0, "correct_q": 0})
    t["attempts"] = int(t.get("attempts", 0)) + 1
    t["total_q"] = int(t.get("total_q", 0)) + total
    t["correct_q"] = int(t.get("correct_q", 0)) + correct
    stats_obj["csv"]["tests"][str(test_id)] = t

def acc_pct(correct: int, total: int) -> float:
    return (correct / total * 100.0) if total else 0.0

# ---------------------------
# Quiz helpers
# ---------------------------
def unique_all_uz(map_: dict):
    seen = set()
    out = []
    for v in map_.values():
        for u in (v.get("uz_list") or []):
            nu = norm_uz(u)
            if u.strip() and nu not in seen:
                seen.add(nu)
                out.append(u)
    return out

def build_question_from_map(map_: dict, en_key: str):
    item = map_[en_key]
    en = item["en"]
    uz_list = item.get("uz_list") or []
    correct = random.choice(uz_list) if uz_list else "(tarjima yo'q)"

    pool = unique_all_uz(map_)
    pool = [u for u in pool if norm_uz(u) != norm_uz(correct)]
    random.shuffle(pool)
    wrongs = pool[:3]

    fillers = ["velosiped", "samolyot", "poyezd", "telefon", "kitob", "daraxt", "stol", "qalam"]
    for f in fillers:
        if len(wrongs) >= 3:
            break
        if norm_uz(f) != norm_uz(correct) and all(norm_uz(f) != norm_uz(w) for w in wrongs):
            wrongs.append(f)

    options = [correct] + wrongs[:3]
    random.shuffle(options)
    return {"en": en, "correct": correct, "options": options}

def start_quiz(mode: str, keys: list[str], map_: dict, csv_test_id: int | None = None):
    st.session_state.quiz_mode = mode           # 'manual' or 'csv'
    st.session_state.quiz_keys = keys
    st.session_state.quiz_index = 0
    st.session_state.quiz_score = 0
    st.session_state.quiz_answers = []
    st.session_state.quiz_page = "run"
    st.session_state.csv_test_id = csv_test_id  # only for csv mode

def reset_quiz_to_menu():
    st.session_state.quiz_page = "menu"
    st.session_state.quiz_mode = None
    st.session_state.quiz_keys = []
    st.session_state.quiz_index = 0
    st.session_state.quiz_score = 0
    st.session_state.quiz_answers = []
    st.session_state.csv_test_id = None

    # lock state reset
    st.session_state.current_q = None
    st.session_state.current_q_id = None
    st.session_state.q_choice = None


# ---------------------------
# State
# ---------------------------
def ensure_state():
    if "picked_en" not in st.session_state:
        st.session_state.picked_en = ""

    if "base_map" not in st.session_state or "csv_meta" not in st.session_state:
        base_map, meta = load_base_csv(str(BASE_CSV))
        st.session_state.base_map = base_map
        st.session_state.csv_meta = meta

    if "user_map" not in st.session_state:
        st.session_state.user_map = load_user_words()

    if "english_list_csv" not in st.session_state:
        st.session_state.english_list_csv = english_list_from_map(st.session_state.base_map)

    if "quiz_page" not in st.session_state:
        st.session_state.quiz_page = "menu"  # menu | csv_list | run | result
    if "quiz_mode" not in st.session_state:
        st.session_state.quiz_mode = None
    if "quiz_keys" not in st.session_state:
        st.session_state.quiz_keys = []
    if "quiz_index" not in st.session_state:
        st.session_state.quiz_index = 0
    if "quiz_score" not in st.session_state:
        st.session_state.quiz_score = 0
    if "quiz_answers" not in st.session_state:
        st.session_state.quiz_answers = []
    if "csv_test_id" not in st.session_state:
        st.session_state.csv_test_id = None

    if "last_translations" not in st.session_state:
        st.session_state.last_translations = []

    if "stats_obj" not in st.session_state:
        st.session_state.stats_obj = load_stats()
            # ---- NEW: quiz question lock state ----
    if "current_q" not in st.session_state:
        st.session_state.current_q = None
    if "current_q_id" not in st.session_state:
        st.session_state.current_q_id = None
    if "q_choice" not in st.session_state:
        st.session_state.q_choice = None


# ---------------------------
# UI
# ---------------------------
st.set_page_config(page_title=APP_TITLE, layout="centered")
ensure_state()

st.title(APP_TITLE)

with st.expander("ğŸ” Debug (CSV tekshirish)"):
    meta = st.session_state.csv_meta
    st.write("CSV path:", str(BASE_CSV.resolve()))
    st.write("CSV loaded:", meta.get("ok"))
    st.write("Rows read:", meta.get("rows"))
    st.write("Detected columns:", meta.get("en_col"), meta.get("uz_col"))
    if meta.get("error"):
        st.error(meta["error"])
    st.write("CSV words:", len(st.session_state.base_map))
    st.write("User words:", len(st.session_state.user_map))

tab_add, tab_test, tab_stats = st.tabs(["â• Soâ€˜z qoâ€˜shish", "ğŸ“ Test", "ğŸ“Š Statistika"])

# ---------------------------
# TAB: ADD
# ---------------------------
with tab_add:
    st.subheader("Soâ€˜z qoâ€˜shish (CSV tavsiyalar + avto tarjima)")

    en = st.text_input(
        "English word yozing",
        key="en_input",
        value=st.session_state.picked_en,
        placeholder="car, color, apple..."
    )

    sug = suggestions(en, st.session_state.english_list_csv, limit=12)
    if en.strip() and sug:
        st.caption("Tavsiyalar (bittasini bosing):")
        cols = st.columns(4)
        for i, w in enumerate(sug):
            with cols[i % 4]:
                if st.button(w, key=f"sug_{w}_{i}"):
                    st.session_state.picked_en = w
                    st.rerun()

    en_word = st.session_state.get("en_input", "").strip()
    en_key = norm_en(en_word)

    st.divider()

    if en_key and en_key in st.session_state.base_map:
        item = st.session_state.base_map[en_key]
        st.success("Soâ€˜z CSVâ€™da bor âœ…")
        existing = item.get("uz_list") or []
        selected = st.multiselect("Tarjimalar (user bazaga saqlash):", existing, default=existing[:1] if existing else [])
        if st.button("User bazaga saqlash ğŸ’¾", type="primary", disabled=(len(selected) == 0)):
            st.session_state.user_map[en_key] = {"en": item["en"], "uz_list": selected}
            save_user_words(st.session_state.user_map)
            st.success("Saqlandi âœ…")
    else:
        st.info("Soâ€˜z CSVâ€™da yoâ€˜q. Avto tarjima qilib user bazaga saqlaysiz.")

        colA, colB = st.columns([1, 1])
        with colA:
            do_translate = st.button("MyMemory tarjima ğŸ”„", disabled=not en_word)
        with colB:
            manual = st.toggle("Tarjimani qoâ€˜lda kiritaman", value=False)

        if do_translate and en_word:
            with st.spinner("Tarjima qilinyapti..."):
                try:
                    st.session_state.last_translations = translate_mymemory(en_word)
                except Exception as e:
                    st.session_state.last_translations = []
                    st.error(f"Tarjima xatosi: {e}")

        if manual:
            uz_text = st.text_area("Uzbek tarjimalar (har qatorga bittadan)", placeholder="mashina\nautomobil")
            selected = [x.strip() for x in uz_text.splitlines() if x.strip()]
        else:
            selected = st.multiselect(
                "Topilgan tarjimalar (tanlang):",
                st.session_state.last_translations,
                default=st.session_state.last_translations[:2] if st.session_state.last_translations else []
            )

        if st.button("Saqlash âœ…", type="primary", disabled=(not en_word or len(selected) == 0)):
            st.session_state.user_map[en_key] = {"en": en_word, "uz_list": selected}
            save_user_words(st.session_state.user_map)
            st.success("Saqlandi âœ…")

    st.divider()
    st.write(f"User soâ€˜zlari: **{len(st.session_state.user_map)}** ta | CSV soâ€˜zlari: **{len(st.session_state.base_map)}** ta")

# ---------------------------
# TAB: TEST
# ---------------------------
with tab_test:
    st.subheader("Test boâ€˜limi")

    # MENU
    if st.session_state.quiz_page == "menu":
        st.write("Qaysi test rejimini tanlaysiz?")

        col1, col2 = st.columns(2)

        with col1:
            if st.button("ğŸ§‘â€ğŸ’» Mening soâ€˜zlarimdan test", type="primary"):
                if len(st.session_state.user_map) < 2:
                    st.error("User soâ€˜zlari kam. Avval kamida 2 ta soâ€˜z saqlang.")
                else:
                    keys = list(st.session_state.user_map.keys())
                    random.shuffle(keys)
                    keys = keys[:QUESTIONS_PER_TEST] if len(keys) >= QUESTIONS_PER_TEST else keys
                    start_quiz("manual", keys, st.session_state.user_map)
                    st.rerun()

        with col2:
            if st.button("ğŸ“š CSV testlar", type="primary"):
                if len(st.session_state.base_map) < QUESTIONS_PER_TEST:
                    st.error("CSVâ€™da test uchun yetarli soâ€˜z yoâ€˜q.")
                else:
                    st.session_state.quiz_page = "csv_list"
                    st.rerun()

        st.caption("Eslatma: Har bir test 10 ta savoldan iborat.")

    # CSV TEST LIST (NEW UI)
    elif st.session_state.quiz_page == "csv_list":
        st.write("CSV testlardan birini tanlang (har biri 10 ta savol):")

        csv_keys_sorted = sorted(st.session_state.base_map.keys())
        total_tests = (len(csv_keys_sorted) + QUESTIONS_PER_TEST - 1) // QUESTIONS_PER_TEST

        tests_stats = st.session_state.stats_obj["csv"]["tests"]

        # list view
        for t_id in range(1, total_tests + 1):
            stat = tests_stats.get(str(t_id))
            if stat and stat.get("total_q", 0) > 0:
                c = int(stat.get("correct_q", 0))
                tot = int(stat.get("total_q", 0))
                w = tot - c
                p = acc_pct(c, tot)
                label = f"Test-{t_id}   âœ… {c} ta   âŒ {w} ta   ({p:.0f}%)"
            else:
                label = f"Test-{t_id}   (hali ishlanmagan)"

            colA, colB = st.columns([3, 1])
            with colA:
                st.write(label)
            with colB:
                if st.button("Boshlash â–¶ï¸", key=f"start_test_{t_id}"):
                    start_idx = (t_id - 1) * QUESTIONS_PER_TEST
                    chunk = csv_keys_sorted[start_idx:start_idx + QUESTIONS_PER_TEST]
                    start_quiz("csv", chunk, st.session_state.base_map, csv_test_id=t_id)
                    st.rerun()

        st.divider()
        if st.button("â¬…ï¸ Ortga", type="secondary"):
            reset_quiz_to_menu()
            st.rerun()

    # RUN QUIZ

    elif st.session_state.quiz_page == "run":
        mode = st.session_state.quiz_mode
        source_map = st.session_state.user_map if mode == "manual" else st.session_state.base_map
        keys = st.session_state.quiz_keys
        idx = st.session_state.quiz_index
        total_q = len(keys)

        if idx >= total_q:
            st.session_state.quiz_page = "result"
            st.rerun()

        # Har savolga unik id
        q_id = f"{mode}:{st.session_state.get('csv_test_id')}:{idx}"

        # Savol o'zgarganda (yoki 1-marta) savolni 1 marta yaratamiz
        if st.session_state.current_q_id != q_id or st.session_state.current_q is None:
            st.session_state.current_q_id = q_id
            current_key = keys[idx]
            st.session_state.current_q = build_question_from_map(source_map, current_key)

            # yangi savolda eski tanlovni tozalash
            st.session_state.q_choice = None

        q = st.session_state.current_q

        if mode == "manual":
            st.info(f"ğŸ§‘â€ğŸ’» Mening soâ€˜zlarim | Savol {idx+1}/{total_q}")
        else:
            st.info(f"ğŸ“š CSV Test-{st.session_state.csv_test_id} | Savol {idx+1}/{total_q}")

        st.markdown(f"### English: **{q['en']}**")

        # Radio (stabil key)
        st.session_state.q_choice = st.radio(
            "Toâ€˜gâ€˜ri tarjimani tanlang:",
            q["options"],
            index=None,
            key="q_choice_widget"
        )

        choice = st.session_state.q_choice

        col1, col2, col3 = st.columns(3)

        with col1:
            if st.button("âœ… Javobni yuborish", type="primary", disabled=(choice is None)):
                ok = (norm_uz(choice) == norm_uz(q["correct"]))

                if ok:
                    st.session_state.quiz_score += 1
                    st.success("Toâ€˜gâ€˜ri âœ…")
                else:
                    st.error(f"Notoâ€˜gâ€˜ri âŒ  Toâ€˜gâ€˜ri javob: **{q['correct']}**")

                st.session_state.quiz_answers.append({
                    "en": q["en"],
                    "your": choice,
                    "correct": q["correct"],
                    "ok": ok
                })

                # Keyingi savolga o'tamiz
                st.session_state.quiz_index += 1

                # Keyingi savol uchun lock reset
                st.session_state.current_q = None
                st.session_state.current_q_id = None
                st.session_state.q_choice = None
                st.session_state.pop("q_choice_widget", None)

                if st.session_state.quiz_index >= total_q:
                    st.session_state.quiz_page = "result"

                st.rerun()

        with col2:
            st.metric("Score", f"{st.session_state.quiz_score}/{total_q}")

        with col3:
            if st.button("ğŸ›‘ Testni toâ€˜xtatish", type="secondary"):
                st.session_state.current_q = None
                st.session_state.current_q_id = None
                st.session_state.q_choice = None
                st.session_state.pop("q_choice_widget", None)
                reset_quiz_to_menu()
                st.rerun()

        st.progress(idx / total_q)




    # RESULT + SAVE STATS
    elif st.session_state.quiz_page == "result":
        mode = st.session_state.quiz_mode
        total_q = len(st.session_state.quiz_keys)
        score = st.session_state.quiz_score
        p = acc_pct(score, total_q)

        st.success(f"Test tugadi âœ… Natija: **{score}/{total_q}**  ({p:.1f}%)")

        # Save stats (ONCE) using a guard
        if "result_saved" not in st.session_state:
            st.session_state.result_saved = False

        if not st.session_state.result_saved:
            # update stats obj
            if mode == "manual":
                record_manual_result(st.session_state.stats_obj, score, total_q)
            else:
                record_csv_result(st.session_state.stats_obj, st.session_state.csv_test_id, score, total_q)

            save_stats(st.session_state.stats_obj)
            st.session_state.result_saved = True

        with st.expander("Urinishlar (detal)"):
            if st.session_state.quiz_answers:
                st.dataframe(st.session_state.quiz_answers, use_container_width=True, hide_index=True)

        colA, colB = st.columns(2)
        with colA:
            if st.button("â¬…ï¸ Test menyusiga qaytish", type="primary"):
                # reset guard
                st.session_state.result_saved = False
                reset_quiz_to_menu()
                st.rerun()
        with colB:
            if st.button("ğŸ” Qayta ishlash", type="secondary"):
                # reset guard
                st.session_state.result_saved = False
                # for manual: start new random; for csv: go back to list
                if mode == "manual":
                    if len(st.session_state.user_map) < 2:
                        st.error("User soâ€˜zlari kam.")
                    else:
                        keys = list(st.session_state.user_map.keys())
                        random.shuffle(keys)
                        keys = keys[:QUESTIONS_PER_TEST] if len(keys) >= QUESTIONS_PER_TEST else keys
                        start_quiz("manual", keys, st.session_state.user_map)
                        st.rerun()
                else:
                    st.session_state.quiz_page = "csv_list"
                    st.session_state.quiz_index = 0
                    st.session_state.quiz_score = 0
                    st.session_state.quiz_answers = []
                    st.rerun()

# ---------------------------
# TAB: STATS (separate)
# ---------------------------
with tab_stats:
    st.subheader("Statistika")

    stats_obj = st.session_state.stats_obj

    # Manual stats
    st.markdown("## ğŸ§‘â€ğŸ’» Mening soâ€˜zlarim testi")
    m = stats_obj.get("manual", {})
    m_attempts = int(m.get("attempts", 0))
    m_total = int(m.get("total_q", 0))
    m_correct = int(m.get("correct_q", 0))
    m_wrong = m_total - m_correct
    m_pct = acc_pct(m_correct, m_total)

    c1, c2, c3, c4 = st.columns(4)
    c1.metric("Testlar soni", m_attempts)
    c2.metric("Jami savollar", m_total)
    c3.metric("Toâ€˜gâ€˜ri", m_correct)
    c4.metric("Aniqlik", f"{m_pct:.1f}%")

    st.divider()

    # CSV stats
    st.markdown("## ğŸ“š CSV testlar statistikasi (Test-1, Test-2...)")
    tests = stats_obj.get("csv", {}).get("tests", {})

    # Build a small table-like list
    if not st.session_state.base_map:
        st.warning("CSV yuklanmagan.")
    else:
        csv_keys_sorted = sorted(st.session_state.base_map.keys())
        total_tests = (len(csv_keys_sorted) + QUESTIONS_PER_TEST - 1) // QUESTIONS_PER_TEST

        rows = []
        for t_id in range(1, total_tests + 1):
            s = tests.get(str(t_id))
            if s and int(s.get("total_q", 0)) > 0:
                tot = int(s.get("total_q", 0))
                cor = int(s.get("correct_q", 0))
                att = int(s.get("attempts", 0))
                rows.append({
                    "Test": f"Test-{t_id}",
                    "Urinish": att,
                    "Toâ€˜gâ€˜ri": cor,
                    "Notoâ€˜gâ€˜ri": tot - cor,
                    "Aniqlik": f"{acc_pct(cor, tot):.1f}%"
                })
            else:
                rows.append({
                    "Test": f"Test-{t_id}",
                    "Urinish": 0,
                    "Toâ€˜gâ€˜ri": 0,
                    "Notoâ€˜gâ€˜ri": 0,
                    "Aniqlik": "-"
                })

        st.dataframe(rows, use_container_width=True, hide_index=True)

    st.divider()
    if st.button("ğŸ§¹ Statistikani tozalash (hammasi)", type="secondary"):
        st.session_state.stats_obj = {"manual": {"attempts": 0, "total_q": 0, "correct_q": 0}, "csv": {"tests": {}}}
        save_stats(st.session_state.stats_obj)
        st.success("Tozalandi âœ…")
